#ifndef _BB_NODE_HPP
#define _BB_NODE_HPP

#include "../graph.hpp"
#include "../solver_stats.hpp"
#include "mp_solver.hpp"
#include "branching_rules.hpp"
#include "column_pool.hpp"
#include "bb_solution.hpp"

#include <memory>
#include <functional>

#include <vector>
#include <string>

#include <boost/optional.hpp>

namespace sgcp {
    struct BBNode {
        // Original graph, before any branching rules modified it.
        std::shared_ptr<const Graph> o;

        // Branching rule to be used to build the local graph. It is kept here in a
        // shared pointer, rather than used immediately in the constructor, in order
        // to build the local graph lazily, only when actually solving the node.
        std::shared_ptr<const BranchingRule> br;

        // Local graph, as modified by the branching rules.
        // It is kept in a shared pointer, so the graph of a certain node is kept alive
        // by the branching rule generated by that node and can then be used in the
        // children nodes to build their own local graphs.
        std::shared_ptr<const Graph> g;

        std::reference_wrapper<ColumnPool> c;
        std::vector<uint32_t> forbidden_columns;
        std::vector<uint32_t> whitelisted_columns;
        std::vector<uint32_t> initial_solution_ids;

        uint32_t node_id;
        uint32_t depth;
        boost::optional<float> bound_from_father;

        std::reference_wrapper<SolverStats> stats;

        static constexpr float min_reduced_cost = 1.0;
        static constexpr float eps = 1e-6;

        BBNode( std::shared_ptr<const Graph> o,
                std::shared_ptr<const BranchingRule> br,
                ColumnPool& c,
                std::vector<uint32_t> forbidden_columns,
                std::vector<uint32_t> initial_solution_ids,
                uint32_t node_id,
                uint32_t depth,
                boost::optional<float> bound_from_father,
                SolverStats& stats);

        boost::optional<BBSolution> solve(float ub, MpSolver& lp_solver, MpSolver& mip_solver);

    private:
        // Checks whether the new columns, added to the column pool by other
        // BB nodes in the time between when this node was created and when
        // it is explored, are to be forbidden. This check uses the BB node's
        // graph and therefore is much more expensive than the check done in
        // the constructor, which uses the branching rule. Anyways, only the
        // columns that were not whitelisted or already forbidden are checked,
        // so the number of checks should be quite limited.
        void check_new_columns();

        BBSolution get_bbsolution(  const MpSolver& mip_solver,
                                    const MpSolution& mp_solution,
                                    const std::vector<StableSet>& new_columns,
                                    float ub) const;
    };
}

#endif